# Practice 2.31

Your coworker gets impatient with your analysis of the overflow condition for two's-complement addition and presents you with the following implementation of `tadd_ok`:

```c
/* Determine whether arguments can be added without overflow */
/* WARNING: This code is buggy. */
int tadd_ok(int x, int y) {
    int sum = x+y;
    return (sum-x == y) && (sum-y == x);
}
```

You look at the code and laugh. Explain why.

---

Let's plug in some values and think about how this function behaves:

With simple positive operations this will return the correct value.

Simple positive operation:
- Assume `x=1` and `y=2` so `sum=3`
- Then: `3-1 == 2` and `3-2 == 1`, so the fuction returns `1`

Similarly with a simple negative operation:
- Assume `x=-1` and `y=-2` so `sum=-3`
- Then: `-3+1 == -2` and `-3+2 == -1`, so the function returns `1`

But, as soon as we consider overflow cases this falls flat quicky...

Positive Overflow:
- Assume `x=1` and `y=TMax_w` so `sum=0`
- Then: `0-1 == TMax` and `0-Tmax_w == 1` -- This makes no sense.

Negative Overflow:
- Assume `x=-1` and `y=TMin_w` so `sum=0`
- Then `0+1 == TMin` and `0-TMin_w == -1` -- This also makes no sense.

The main issue with this implementation is that it really is only checking if the value is equal to itself becase of the abelian nature of the addition since:
`sum-x == y` => `x+y-x == y` => `y+x-x == y` => `y==y` -- Pointless
