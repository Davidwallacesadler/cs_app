# Practice 2.31

You are assigned the task of writing code for a function `tsub_ok`, with arguments `x` and `y`, that will return `1` if computing `x-y` does not cause overflow. Having just written the code for Problem 2.30, you write the following:

```c
/* Determine whether arguments can be subtracted without overflow */
/* WARNING: This code is buggy. */
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
```

For what values of `x` and `y` will this function give incorrect results? Writing a correct version of this is left as an exercise (2.74)

---

The function should return the right result for all values except for the `y = Tmin_w`

Since we know from the book that `Tmin_w` is its own additive inverse we should test it specifically (Adding `Tmin_w` to itself will always yield zero because the sum will overflow the word size since we are adding two numbers with MSB `1` and are constrained to a word size)

1. `x > 0`, `y = Tmin_w`

For any positive number x the result will be negative - since `|Tmin_w| = Tmax_w + 1`:

If we have `w = 4`:
`Tmin_4` => `1000` => -8
`Tmax_4` => `0111` = 7

So even if `x = Tmax_4` then `s = -1` which is still negative and did not overflow so the function should return `1` -- lets test it.

`tadd_ok` checks `sum >= x`, which can naver be true since x is positive and the resulting sum is always negative so the function returns `0` which is the incorrect result!

2. `x < 0`, `y = Tmin_w`

If `x = Tmin_w` then we know `s = 0` since `Tmin_w` is its own additive inverse.

For all other negative numbers x, we should have a negative overflow so the function should return `0`.

`tadd_ok` check `sum >= x` which will always return `1` since we will always have negative overflow OR will have 0 if `x = Tmin_w`.

So when `y = Tmin`, this function returns the opposite result of what it shuold!