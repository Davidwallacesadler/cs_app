# Practice 2.25

Consider the following code that attempts to sum the elements of an array `a`, where the number of elements is given by parameter `length`:

```c
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;

    for (i = 0; i <= length-1; i++)
        result += a[i];

    return result;
}
```

When run with argument length equal to `0`, this code should return `0.0`. Instead, it encounters a memory error.

[A.](#a) Explain why this happens.

[B.](#b) Show how this can be corrected.

---

## A.
To explain what happens with an empty array and 0 length, let's plug in those values and walk through the function to see where the issue is:

```c
int main() {
    float list[0];
    unsigned length = 0;

    sum_elements(list, length);
}
```

```
sum_elements:

PARAMS:
a = []
length = 0 (unisgned)

LOCAL VARS:
int i (uninitialized)
float result = 0

START LOOP:
- iterator: i = 0
- condition: i <= length-1, i <= 0-1 (OVERFLOW: 0-1 results in UMax), i <= UMax (Always true!)
- update: i++

FIRST ITERATION:
- Check condition: is 0 <= UMax? Yes.
- result += a[0] (OUT OF BOUNDS ACCESS: This causes the memory error since the array is empty!)
```

## B.
This could be corrected by ensuring we do not subtract from 0 for the loop condition. We could do this by just applying some logic for calculating the loop length:

```c
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;
    unsigned len = length;
    if (len > 0)
        len = length - 1

    for (i = 0; i <= len; i++)
        result += a[i]

    return result;
}
```

OR we could just improve the loop condition by only checking for less than and not less than or equal:

```c
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;

    for (i = 0; i < length; i++)
        result += a[i]

    return result;
}
```