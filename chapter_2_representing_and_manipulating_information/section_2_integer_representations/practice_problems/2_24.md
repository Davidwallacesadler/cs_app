# Practice 2.24

Suppose we truncate a 4-bit value (represented by hex digitis 0 through F) to a 3-bit value (represented by hex digits 0 through 7). Fill in the table below showing the effect of truncation for some cases, in terms of the unsighed and two's complement interpretations of those bit patterns.

Hex:
| Original | Truncated | 
| -------- | --------- | 
| 1        | 1         | 
| 3        | 3         | 
| 5        | 5         | 
| C        | 4         | 
| E        | 6         | 

Unsigned:
| Original | Truncated | 
| -------- | --------- | 
| 1        | [A.](#a)  | 
| 3        | [B.](#b)  | 
| 5        | [C.](#c)  | 
| 12       | [D.](#d)  | 
| 14       | [E.](#e)  | 

Two's Complement:
| Original | Truncated | 
| -------- | --------- | 
| 1        | [F.](#f)  | 
| 3        | [G.](#g)  | 
| 5        | [H.](#h)  | 
| -4       | [I.](#i)  | 
| -2       | [J.](#j)  | 

[K.](#k) Explain how Equations 2.9 and 2.10 apply to these cases.

---

## A.

Truncating 1 (unsigned 4-bit) to unsigned 3-bit:

```
0001 (4-bit) -> 3-bit
B2U(001) = B2U(0001) mod 2^3 (Equation 2.9, where k=3, w=4)
=> 1 mod 8
------
=> 1 (0b001)
```

## B.

Truncating 3 (unsigned 4-bit) to unsigned 3-bit:

```
0011 (4-bit) -> 3-bit
B2U(011) = B2U(0011) mod 2^3 (2.9)
=> 3 mod 8
------
=> 3 (0b011)
```

## C.

Truncating 5 (unsigned 4-bit) to unsigned 3-bit:

```
0101 (4-bit) -> 3-bit
B2U(101) = B2U(0101) mod 2^3 (2.9)
=> 5 mod 8
------
=> 5 (0b101)
```

## D.

Truncating 12 (unsigned 4-bit) to unsigned 3-bit:

```
1100 (4-bit) -> 3-bit
B2U(100) = B2U(1100) mod 2^3 (2.9)
=> 12 mod 8
------
=> 4 (0b100)
```

## E.

Truncating 14 (unsigned 4-bit) to unsigned 3-bit:

```
1110 (4-bit) -> 3-bit
B2U(110) = B2U(1110) mod 2^3 (2.9)
=> 14 mod 8
------
=> 6 (0b110)
```

## F.

Truncating 1 (two's complement 4-bit) to two's complement 3-bit:

```
0001 (4-bit) -> 3-bit
B2T(001) = B2T(B2U(1110) mod 2^3) (2.10)
=> B2T(1 mod 8)
=> B2t(1)
=> B2T(001)
------
=> 1 (0b001)
```

## G.

Truncating 3 (two's complement 4-bit) to two's complement 3-bit:

```
0011 (4-bit) -> 3-bit
B2T(011) = B2T(B2U(0011) mod 2^3) (2.10)
=> B2T(3 mod 8)
=> B2T(3)
=> B2T(011)
------
=> 3 (0b011)
```

## H.

Truncating 5 (two's complement 4-bit) to two's complement 3-bit:

```
0101 (4-bit) -> 3-bit
B2T(101) = B2T(B2U(0101) mod 2^3) (2.10)
=> B2T(5 mod 8)
=> BST(5)
=> B2T(101)
------
=> -3 (0b101)
```

## I.

Truncating -4 (two's complement 4-bit) to two's complement 3-bit:

```
1100 (4-bit) -> 3-bit
B2T(100) = B2T(B2U(1100) mod 2^3) (2.10)
=> B2T(-4 mod 8)
=> B2T(-4)
=> B2T(100)
------
=> -4 (0b100)
```

## J.

Truncating -2 (two's complement 4-bit) to two's complement 3-bit:

```
1110 (4-bit) -> 3-bit
B2T(110) = B2T(B2U(1110) mod 2^3) (2.10)
=> B2T(-2 mod 8)
=> B2T(-2)
=> B2T(110)
------
=> -2 (0b110)
```

## K.
For the unsigned cases (A-E) we apply equation 2.9 which truncates the unsigned value by modding the original value by 2^k which results in a value truncated to k bits. We do exactly the same for two's complement cases (F-J) but then apply binary to two's complement conversion to the resulting truncated value to interpret the most significant bit as the sign bit.